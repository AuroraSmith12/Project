# 树莓派

##### 账号：pi

##### 密码：raspberry

## 1.树莓派HDMI登陆

## 2.树莓派串口登陆：[(13条消息) 树莓派--串口登录_树莓派串口登录_一只青木呀的博客-CSDN博客](https://blog.csdn.net/weixin_45309916/article/details/107487925)

## 3.网络登陆树莓派：

```c
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
```

```c
network={
        ssid="你的无线网名字"
        psk="密码"
        key_mgmt=WPA-PSK//这个是加密的方式，可以不写
}

```

[(13条消息) 树莓派的几种登录方式及树莓派的网络配置_FHNCSDN的博客-CSDN博客](https://blog.csdn.net/FHNCSDN/article/details/108918265?ops_request_misc=%7B%22request%5Fid%22%3A%22168136199716800226518715%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=168136199716800226518715&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-108918265-null-null.142^v83^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=网络登陆树莓派&spm=1018.2226.3001.4187)

##### 然后打开ssh功能

```
sudo raspi-config
```

##### 最后重启一下

##### 固定IP地址

```
sudo nano /etc/rc.local
```

##### 在最后fi 	exit0之间加上

```
ifconfig wlan0 xxx.xxx.xx.xxx(ifconfig找到的ip)
```

##### 然后重启

```
sudo reboot
```



## ssh登陆，树莓派连接的WiFi要和电脑连接的WiFi是同一个（同一个局域网，这样mobaXterm才能用）



## 4.树莓派图形xrdp界面登陆

##### 首先树莓派下载

```
sudo apt-get install xrdp
```

然后Windows中搜索	“远程桌面连接”输入树莓派IP就可以连接

如果连不上就关闭防火墙

或者将树莓派的xrdp进行卸载再重新安装



卸载指令

```
sudo apt autoremove xxxxx
```





## 树莓派和Windows的FileZilla文件共享



![1](D:\Desktop\raspberry\raspberry\1.png)

##### 安装软件指令：

```c
sudo apt-get install XXXX
```

##### 树莓派换镜像源

```
sudo nano /etc/apt/sources.list
```

## Linux中的库

[(13条消息) Linux中的库（静态库和动态库）详解_linux 静态库_石子君的博客-CSDN博客](https://blog.csdn.net/qq_44333320/article/details/125486124?ops_request_misc=%7B%22request%5Fid%22%3A%22168136559916800182197249%22%2C%22scm%22%3A%2220140713.130102334..%22%7D&request_id=168136559916800182197249&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-125486124-null-null.142^v83^insert_down38,201^v4^add_ask,239^v2^insert_chatgpt&utm_term=Linux中的库&spm=1018.2226.3001.4187)



## 树莓派串口通信

##### 首先：修改cmdline.txt文件

```
cd /boot

sudo vi cmdline.txt
```

##### 然后删除以下内容（禁用串口调试功能，改成通信功能）

```
console=ttyAMA0,115200
```

![3](D:\Desktop\raspberry\raspberry\3.png)

##### 最后重启

```
sudo reboot
```

##### 代码如下：

```c
#include <stdio.h>
#include <wiringSerial.h>
#include <wiringPi.h>
int main()
{
        int err_ret = wiringPiSetup ();
        if(err_ret == -1)
        {
                printf("setup failed\n");
                return -1;
        }
        int fd =  serialOpen ("/dev/ttyAMA0", 115200);
        if(fd == -1)
        {
                printf("serial open failed\n");
                return -1;
        }

        int cnt = 0;
        for(cnt = 0 ;cnt < 10 ;cnt ++)
        {
        serialPutchar (fd, 'A'+cnt);
        }

-- VISUAL --                                        26        1,1           Top

```

##### 结果如下：

![2](D:\Desktop\raspberry\raspberry\2.png)





## 树莓派交叉编译工具链的安装



## 树莓派mjpg-streamer实现监控功能调试

[(9条消息) 树莓派安装MJPG-streamer_mjpg-streamer还维护吗_冷月枫啊的博客-CSDN博客](https://blog.csdn.net/lengyuefeng212/article/details/113363299)

[(9条消息) 树莓派（raspberry pi）mjpg——streamer 远程识别监控（换源+csl摄像头+usb摄像头零基础指导以及一些过程问题的解决）_放小孩的羊的博客-CSDN博客](https://blog.csdn.net/qq_53951823/article/details/116373500)

[树莓派3B + Pi摄像头+mjpg-streamer-百度经验 (baidu.com)](https://jingyan.baidu.com/article/47a29f2474a555c01523994c.html)

#####  input_uvc.so 是usb摄像头

##### input_raspicam.so是树莓派摄像头

##### 将start.sh中input_uvc.so改为input_raspicam.so



![4](D:\Desktop\raspberry\raspberry\4.jpg)



![5](D:\Desktop\raspberry\raspberry\5.jpg)



## socket,tcp,udp,http,之间的区别和原理

[socket、tcp、udp、http 的认识及区别 - 叫我程某某 - 博客园 (cnblogs.com)](https://www.cnblogs.com/chengzhengfu/p/4584510.html)





## http,https,libcurl协议相关

[Http协议之libcurl实现 - 谢呈勖 - 博客园 (cnblogs.com)](https://www.cnblogs.com/xietianjiao/p/13260021.html)

##### url就是网址



## libcurl等第三方库的通用编译方法

##### 首先从GitHub上下载源码

```bash
https://github.com/curl/curl/releases/tag/curl-7_71_1
```

##### 下载后放到Ubuntu中进行解压

```
tar -xjf curl-7.71.1.tar.bz2 
```

##### 进入解压好的文件夹

```
cd curl-7.71.1/
```

##### 可以看看docs中的INSTALL.md，里面有各种环境的安装方法，我们当前的环境是linux

![6](D:\Desktop\raspberry\raspberry\6.png)

```
cd curl-7.71.1/
```

##### 进入curl-7.71.1这个文件夹，现在开始进行编译

```
./configure --prefix=$PWD/_install
```

##### 将编译后生成的东西放到当前工作路径的_install文件夹底下

##### 也可以指定交叉编译工具

```
./configure --prefix=$PWD/_install --host=arm-linux-gnueabihf-gcc 
```

##### 然后

```
make
```

##### 最后

```
make install
```

##### 进入到_install文件夹查看一下编译生成的文件

![7](D:\Desktop\raspberry\raspberry\7.png)



## 调用libcurl编程访问百度主页

##### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>

#define true 1
#define false 0
typedef unsigned int bool;

bool getUrl(char *filename)
{
        CURL *curl;
        CURLcode res;
        FILE *fp;
        if ((fp = fopen(filename, "w")) == NULL)  // 返回结果用文件存储
                return false;
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: Agent-007");
        curl = curl_easy_init();    // 初始化
        if (curl)
        {
                //curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");// 代理
                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);// 改协议头
                curl_easy_setopt(curl, CURLOPT_URL,"http://www.baidu.com");
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件
                curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件
                res = curl_easy_perform(curl);   // 执行
                if (res != 0) {

                        curl_slist_free_all(headers);
                        curl_easy_cleanup(curl);
                }
                fclose(fp);
                return true;
        }
}
bool postUrl(char *filename)
{
        CURL *curl;
        CURLcode res;
        FILE *fp;
        if ((fp = fopen(filename, "w")) == NULL)
                return false;
        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "&logintype=uid&u=xieyan&psw=xxx86");    // 指定post内容
                //curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");
                curl_easy_setopt(curl, CURLOPT_URL, " http://mail.sina.com.cn/cgi-bin/login.cgi ");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
                res = curl_easy_perform(curl);
                curl_easy_cleanup(curl);
        }
        fclose(fp);
        return true;
}
int main(void)
{
        getUrl("/tmp/get.html");
        postUrl("/tmp/post.html");
}
                                                           
```

##### 编译

```bash
gcc test2.c -I ../curl-7.71.1/include/  -L ../curl-7.71.1/_install/lib/  -lcurl
```

##### 有报错

![8](D:\Desktop\raspberry\raspberry\8.png)

##### 需要配置环境变量

```
export LD_LIBRARY_PATH=/home/zlw/DailyCode/raspberry_study/curl-7.71.1/_install/lib
```

##### 也可以永久配置环境：

```bash
gedit ~/.bashrc
```

##### 在最后添加以下内容

```bash
export LD_LIBRARY_PATH=/home/zlw/DailyCode/raspberry_study/curl-7.71.1/_install/lib
```



![10](D:\Desktop\raspberry\raspberry\10.png)

##### 然后重启虚拟机就OK了

![](D:\Desktop\raspberry\raspberry\9.png)

##### 这样子就可以运行了



## libcurl函数库常用字段解读并设置数据读取回调函数

##### read_func是回调函数

##### 代码：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[10240] = {0};
        strncpy(buf, ptr, 10240);
        printf("======================get data======================\n");
        printf("%s\n",buf);

}

bool getUrl(char *filename)
{
        CURL *curl;
        CURLcode res;
        FILE *fp;
        if ((fp = fopen(filename, "w")) == NULL)  // 返回结果用文件存储
                return false;
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, "Accept: Agent-007");
        curl = curl_easy_init();    // 初始化
        if (curl)
        {
                //curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");// 代理
                curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);// 改协议头
                curl_easy_setopt(curl, CURLOPT_URL,"http://www.baidu.com");
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                //curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp); //将返回的http头输出到fp指向的文件
                //curl_easy_setopt(curl, CURLOPT_HEADERDATA, fp); //将返回的html主体数据输出到fp指向的文件
                res = curl_easy_perform(curl);   // 执行
                if (res != 0) {

                        curl_slist_free_all(headers);
                        curl_easy_cleanup(curl);
                }
                fclose(fp);
                return true;
        }
}
bool postUrl(char *filename)
{
        CURL *curl;
        CURLcode res;
        FILE *fp;
        if ((fp = fopen(filename, "w")) == NULL)
                return false;
        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "&logintype=uid&u=xieyan&psw=xxx86");    // 指定post内容
                //curl_easy_setopt(curl, CURLOPT_PROXY, "10.99.60.201:8080");
                curl_easy_setopt(curl, CURLOPT_URL, " http://mail.sina.com.cn/cgi-bin/login.cgi ");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEDATA, fp);
                res = curl_easy_perform(curl);
                curl_easy_cleanup(curl);
        }
        fclose(fp);
        return true;
}
int main(void)
{
        getUrl("/tmp/get.html");
        postUrl("/tmp/post.html");
}
                                   
```



##### 输出结果：

![11](D:\Desktop\raspberry\raspberry\11.png)



[(9条消息) Ubuntu连接不上网络问题的解决方法_ubuntu连接不了网络的解决方法_菜鸡什么时候能变强的博客-CSDN博客](https://blog.csdn.net/qq_44853430/article/details/109974779)





## 编程实现人脸识别第一次

### 平台：[翔云_人工智能_API_服务平台 (netocr.com)](http://netocr.com/)



##### 代码：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

}
bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char img1[12];
        char img2[12];
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = " 9e300b424e7e4a20a7dabd3799410c56";
        int typeID = 21;
        char *formate = "xml";

        postString = (char*)malloc(strlen(key)+strlen(secret)+2048);


        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeID=%d&formate=%s",
                                  "",     "",    key,    secret,   typeID,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL, "https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        return true;
}
int main(void)c
{
        postUrl();
}

```

##### 运行结果：

![18](D:\Desktop\raspberry\raspberry\18.png)

##### 原因：没有传递两张图片参数

## 编译openssl支持libcurl的https访问

##### 首先删除之前编译后生成的文件（因为翔云这个平台需要ssl）

```bash
rm -rf _install
```

##### 然后重新配置

```bash
./configure --prefix=$PWD/_install --with-ssl
```

![12](D:\Desktop\raspberry\raspberry\12.png)



##### 安装openssl

[(9条消息) 交叉编译：OpenSSL_使wget支持https_钱德勒宾的博客-CSDN博客](https://blog.csdn.net/weixin_38184741/article/details/86554438)



![13](D:\Desktop\raspberry\raspberry\13.png)

##### 看README，了解怎么安装

##### 再去看INSTALL,看看怎么安装



![14](D:\Desktop\raspberry\raspberry\14.png)

##### 安装到系统路径底下去



```
./config
```

![15](D:\Desktop\raspberry\raspberry\15.png)

##### 然后

```bash
make
```

##### 最后

```bash
sudo make install
```

##### 然后进入到cd curl-7.71.1/目录，重新进行编译curl

![16](D:\Desktop\raspberry\raspberry\16.png)

```bash
./configure --prefix=$PWD/_install --with-ssl
```

```bash
make
```

```bash
sudo make install
```

![17](D:\Desktop\raspberry\raspberry\17.png)

##### 然后就可以运行代码来访问翔云平台（将代码的typeID改为typeId这样就解决了产品类型错误）

![18](D:\Desktop\raspberry\raspberry\18.png)



## 编程实现人脸识别第二次加入图片base64编码



##### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>


#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);
}
bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char *img1;
        char *img2;
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = "9e300b424e7e4a20a7dabd3799410c56";
        int typeID = 21;
        char *formate = "xml";

        system("base64 pyy1.jpg > tmpFile1");
        system("base64 pyy2.jpg > tmpFile2");

        int fd1 = open("./tmpFile1",O_RDWR);
        int fd2 = open("./tmpFile2",O_RDWR);

        int fd1_len = lseek(fd1,0,SEEK_END);
        lseek(fd1,0,SEEK_SET);

        int fd2_len = lseek(fd2,0,SEEK_END);
        lseek(fd2,0,SEEK_SET);

        img1 = (char*)malloc(fd1_len+20);
        img2 = (char*)malloc(fd2_len+20);

        memset(img1,'\0',fd1_len+20);
        memset(img2,'\0',fd2_len+20);

        read(fd1,img1,fd1_len);
        read(fd2,img2,fd2_len);
        postString = (char*)malloc(strlen(key)+strlen(secret)+fd1_len+fd2_len+1024);

        memset(postString,'\0',strlen(postString));

        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                        img1,     img2,    key,    secret,   typeID,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL,"https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        free(img1);
        free(img2);
        free(postString);
        close(fd1);
        close(fd2);
        return true;
}
int main(void)
{
        postUrl();
}

```

##### 结果：

![19](D:\Desktop\raspberry\raspberry\19.png)

##### 代码中的这些内容要与网页的相对应

![20](D:\Desktop\raspberry\raspberry\20.png)



![21](D:\Desktop\raspberry\raspberry\21.png)



## 人脸识别成功并封装Base64编码函数

##### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>


#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

        printf("=====================result=======================\n");
        if(strstr(buf,"是") != NULL)
        {
                printf("the same person\n");
        }
        else
        {
                printf("different person\n");
        }

}
char* getPicBase64FromFile(char *filePath)
{

        char *bufPic;
        char cmd[128]={'\0'};

        sprintf(cmd,"base64 %s >tmpFile",filePath);

        system(cmd);

        int fd = open("./tmpFile",O_RDWR);
        int fd_len = lseek(fd,0,SEEK_END);
        lseek(fd,0,SEEK_SET);

        bufPic = (char*)malloc(fd_len+2);

        memset(bufPic,'\0',fd_len+2);

        read(fd,bufPic,fd_len);

        close(fd);

        system("rm -rf tmpFile");

        return bufPic;

}

bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char *img1;
        char *img2;
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = "9e300b424e7e4a20a7dabd3799410c56";
        int typeID = 21;
        char *formate = "xml";


        //图片转字符流

        img1 = getPicBase64FromFile("./pyy1.jpg");

        img2 = getPicBase64FromFile("./pyy2.jpg");


        postString = (char*)malloc(strlen(key)+strlen(secret)+strlen(img1)+strlen(img2)+1024);
        memset(postString,'\0',strlen(postString));

        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                        img1,     img2,    key,    secret,   typeID,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL,"https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        free(img1);
        free(img2);
        free(postString);
        return true;
}
int main(void)
{
        postUrl();
}

```

##### 结果如下：

![22](D:\Desktop\raspberry\raspberry\22.png)





## 树莓派的人脸识别（2023.4.17-09点25分）

[(11条消息) 树莓派3B摄像头的详细使用教程（拍照+录像+监控）_树莓派摄像头拍照_追着太阳跑1的博客-CSDN博客](https://blog.csdn.net/weixin_42714122/article/details/128479602?spm=1001.2014.3001.5502)

[(10条消息) 树莓派4B摄像头的详细使用教程（拍照+录像+监控）_树莓派拍照_小叶小叶不要熬夜的博客-CSDN博客](https://blog.csdn.net/weixin_45994747/article/details/109605765)

[(10条消息) 树莓派 | Linux 中怎么查看图片_树莓派查看图片_疯魔coding君的博客-CSDN博客](https://blog.csdn.net/qq_44214671/article/details/113832481)

[Linux 命令详解（三）./configure、make、make install 命令 - Tinywan - 博客园 (cnblogs.com)](https://www.cnblogs.com/tinywan/p/7230039.html#:~:text=比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。 2、make,是用来编译的，它从Makefile中读取指令，然后编译。 3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。)

[(11条消息) linux下安装OpenSSL和libcurl库_迷失的流氓兔的博客-CSDN博客](https://blog.csdn.net/qq_46058503/article/details/115441647)



##### 下载openssl

```bash
wget https://www.openssl.org/source/openssl-1.1.1a.tar.gz
```

##### 下载libcurl库

##### 从GitHub上下载

```bash
https://github.com/curl/curl/releases/tag/curl-7_71_1
```

##### 然后分别解压出来

```bash
tar -xjf curl-7.71.1.tar.bz2 
```

```bash
tar -xzf openssl-1.1.1a.tar.gz
```

##### 得到以下文件

![23](D:\Desktop\raspberry\raspberry\23.png)

### 首先编译openssl

##### 进入到openssl这个目录

```bash
cd openssl-1.1.1a/
```

##### 安装到系统路径底下去

```bash
./config
```

```bash
make
```

```bash
sudo make install
```

### 然后再去编译curl

##### 进入到curl这个目录

```bash
cd curl-7.71.1/
```

##### 然后编译

```bash
./configure --prefix=$PWD/_install --with-ssl
```

```bash
make
```

```bash
sudo make install
```

##### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

}
bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char img1[12];
        char img2[12];
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = "9e300b424e7e4a20a7dabd3799410c56";
        int typeId = 21;
        char *formate = "xml";

        postString = (char*)malloc(strlen(key)+strlen(secret)+2048);


        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                                  "",     "",    key,    secret,   typeId,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL, "https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        return true;
}
int main(void)
{
        postUrl();
}



```

##### 编译

```bash
gcc test1.c -I ../curl-7.71.1/_install/include -L ../curl-7.71.1/_install/lib -lcurl -o test1
```

##### 发生报错

```bash
/curl-7.71.1/_install/lib//libcurl.so: undefined reference to `SSL_CTX_set_keylog_callback@OPENSSL_1_1_1'
./curl-7.71.1/_install/lib//libcurl.so: undefined reference to `SSL_CTX_set_post_handshake_auth@OPENSSL_1_1_1'
./curl-7.71.1/_install/lib//libcurl.so: undefined reference to `SSL_CTX_set_ciphersuites@OPENSSL_1_1_1'

```

##### 按照上面编译时报这种错误时，指令上加上-lssl -lcrypto就可以啦。如下：

```bash
gcc test1.c -I ../curl-7.71.1/_install/include -L ../curl-7.71.1/_install/lib -lcurl -o test1 -lssl -lcrypto
```

##### 执行程序，又发生报错：

```bash
openssl: /usr/lib/x86_64-linux-gnu/libssl.so.1.1: version OPENSSL_1_1_1’ not found (required by openssl)
```

##### 这种情况是LD_LIBRARY_PATH这个环境变量没有指定。

##### 设置环境变量(临时)：

```bash
export LD_LIBRARY_PATH=/usr/local/lib
```

##### 永久设置环境变量：

```bash
sudo vi ~/.bashrc
```

##### 然后再最后加上以下内容

```bash
export LD_LIBRARY_PATH=/usr/local/lib
```

![24](D:\Desktop\raspberry\raspberry\24.png)

##### 然后重启树莓派

```bash
sudo reboot
```

##### 然后编译，运行刚刚的代码，就可以运行了。

![25](D:\Desktop\raspberry\raspberry\25.png)



## 加入图片，进行人脸识别

##### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>


#define true 1
#define false 0
typedef unsigned int bool;


size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

        printf("=====================result=======================\n");
        if(strstr(buf,"是") != NULL)
        {
                printf("the same person\n");
        }
        else
        {
                printf("different person\n");
        }

}
char* getPicBase64FromFile(char *filePath)
{

        char *bufPic;
        char cmd[128]={'\0'};

        sprintf(cmd,"base64 %s >tmpFile",filePath);

        system(cmd);

        int fd = open("./tmpFile",O_RDWR);
        int fd_len = lseek(fd,0,SEEK_END);
        lseek(fd,0,SEEK_SET);

        bufPic = (char*)malloc(fd_len+2);

        memset(bufPic,'\0',fd_len+2);

        read(fd,bufPic,fd_len);

        close(fd);

        system("rm -rf tmpFile");

        return bufPic;

}

bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char *img1;
        char *img2;
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = "9e300b424e7e4a20a7dabd3799410c56";
        int typeID = 21;
        char *formate = "xml";

	//拍摄图片
	system("raspistill -o after.jpg -t 1000");

        //图片转字符流

        img1 = getPicBase64FromFile("./before.jpg");

        img2 = getPicBase64FromFile("./after.jpg");
	
	//删除拍摄的图片
	system("rm -rf after.jpg");

        postString = (char*)malloc(strlen(key)+strlen(secret)+strlen(img1)+strlen(img2)+1024);
        memset(postString,'\0',strlen(postString));

        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                        img1,     img2,    key,    secret,   typeID,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL,"https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        free(img1);
        free(img2);
        free(postString);
        return true;
}
int main(void)
{
        postUrl();
}



```

##### 首先用树莓派拍摄一张自己的照片（用作识别），然后在代码里面写一个树莓派拍摄照片的代码，然后这两张照片进行比对

![27](D:\Desktop\raspberry\raspberry\27.png)

##### 编译

```bash
gcc test3.c -I ../curl-7.71.1/_install/include -L ../curl-7.71.1/_install/lib -lcurl -o test3
```

##### 运行结果

![26](D:\Desktop\raspberry\raspberry\26.png)



## 树莓派人脸识别加上wiringPi库



### 代码如下：

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<wiringPi.h>

#define true 1
#define false 0
typedef unsigned int bool;


int gpio_init(void)
{
	int err_num = wiringPiSetup();
	pinMode(1, OUTPUT);
	digitalWrite(1,HIGH);
	return err_num;
}

void lock_open(void)
{
	digitalWrite(1,LOW);
	delay(1000);
	digitalWrite(1,HIGH);
}

size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

        printf("=====================result=======================\n");
        if(strstr(buf,"是") != NULL)
        {
		lock_open();
                printf("the same person\n");
        }
        else
        {
                printf("different person\n");
        }

}
char* getPicBase64FromFile(char *filePath)
{

        char *bufPic;
        char cmd[128]={'\0'};

        sprintf(cmd,"base64 %s >tmpFile",filePath);

        system(cmd);

        int fd = open("./tmpFile",O_RDWR);
        int fd_len = lseek(fd,0,SEEK_END);
        lseek(fd,0,SEEK_SET);

        bufPic = (char*)malloc(fd_len+2);

        memset(bufPic,'\0',fd_len+2);

        read(fd,bufPic,fd_len);

        close(fd);

        system("rm -rf tmpFile");

        return bufPic;

}

bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char *img1;
        char *img2;
        char *key = "MPWeajiYjAtrYDfZweE8vk";
        char *secret = "9e300b424e7e4a20a7dabd3799410c56";
        int typeID = 21;
        char *formate = "xml";

	//拍摄图片
	system("raspistill -o after.jpg -t 1000");

        //图片转字符流

        img1 = getPicBase64FromFile("./before.jpg");

        img2 = getPicBase64FromFile("./after.jpg");
	
	//删除拍摄的图片
	system("rm -rf after.jpg");

        postString = (char*)malloc(strlen(key)+strlen(secret)+strlen(img1)+strlen(img2)+1024);
        memset(postString,'\0',strlen(postString));

        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                        img1,     img2,    key,    secret,   typeID,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL,"https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        free(img1);
        free(img2);
        free(postString);
        return true;
}
int main(void)
{
	int err_num = gpio_init();
	if(err_num == -1)
	{
		return -1;
	}

        postUrl();
}



```



### 编译

```bash
gcc test4.c -I ../curl-7.71.1/_install/include -L ../curl-7.71.1/_install/lib -lcurl -o test4 -lwiringPi
```

### 运行

![28](D:\Desktop\raspberry\raspberry\28.png)





![29](D:\Desktop\raspberry\raspberry\29.jpg)





## 树莓派自启动

[(11条消息) 树莓派程序开机自启动方法总结_树莓派 程序启动状态_老野_的博客-CSDN博客](https://blog.csdn.net/feixuedongji/article/details/79891735)

#### 第二种方法比较好用







[(11条消息) 智能家居 (10) ——人脸识别祥云平台编程使用(编译libcurl库支持SSL，安装SSL依赖库libssl、libcrypto)_openssl 依赖库_行稳方能走远的博客-CSDN博客](https://blog.csdn.net/zhuguanlin121/article/details/117172218#comments_26097681)

#### 看上面这个博客的往期文章



# 智能家居代码架构---简单工厂模式


代码设计经验的总结，稳定，拓展性更强。一系列编程思想
算法不是设计模式，因为算法致力于解决问题而非设计问题。

ftp get put cd lcd pwd lls ls....
乱

### 什么是设计模式	

设计模式通常描述了一组相互紧密作用的类与对象。（java）
c    面向过程，一门不太友好的面向对象语言
java 面向对象

建筑设计领域引入到计算机科学中来的

23种 代码更容易被他人理解、保证代码可靠性、程序的重用性。
[设计模式 | 菜鸟教程 (runoob.com)](https://www.runoob.com/design-pattern/design-pattern-tutorial.html)
百科
[软件设计模式_百度百科 (baidu.com)](https://baike.baidu.com/item/软件设计模式/2117635?fr=aladdin)

### 什么是类和对象

类是一种用户定义的引用数据类型，也称类类型。结构体
对象： 类的一种具象

struct Animal{
	int age;
	int sex;       //成员属性
	void *peat();
	void *pbeat(); //成员方法
}

struct Animal dog;
struct Animal cat;
struct Animal person;

### 什么是工厂模式

工厂模式（Factory Pattern）是最常用的设计模式之一。
这种类型的设计模式属于创建型模式，它提供了一种创建对象的 (最 佳)方式。

在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。



##### 代码如下：

```c
#include <stdio.h>


struct Animal{
        char name[20];
        int sex;	//成员属性
        void (*peat)();//成员方法

};

void dogEat(void)
{
        printf("dog eats shit\n");
}
void catEat(void)
{
        printf("cat eats fish\n");
}
int main()
{
        struct Animal cat;
        struct Animal dog;

        cat.peat = catEat;
        dog.peat = dogEat;

        dog.peat();
        cat.peat();

        return 0;
}
```

##### 更好的写法：

```c
#include <stdio.h>


struct Animal{
        char name[20];
        int sex;
        void (*peat)();

};

void dogEat(void)
{
        printf("dog eats shit\n");
}
void catEat(void)
{
        printf("cat eats fish\n");
}
int main()
{
        struct Animal cat = {
                            .peat = catEat//选择性赋值
                                };
        struct Animal dog = {
                            .peat = dogEat
                                };

        dog.peat();
        cat.peat();

        return 0;
}
```

### 工厂模式的实现

![30](D:\Desktop\raspberry\raspberry\30.png)



#### animal.h

```c
#include <stdio.h>


struct Animal{
		char name[128];
		int  age;
		int  sex;
		int  others;
		void (*peat)();
		void (*pbeat)();
		void (*test)();

		struct Animal *next;

};

struct Animal* putPersonInLink(struct Animal *phead);//先声明
struct Animal* putCatInLink(struct Animal *phead);
struct Animal* putDogInLink(struct Animal *phead);

```

#### mainPro.c

```c
#include "animal.h"
#include <string.h>

struct Animal* findUtilByName(char* str, struct Animal* phead)//结构体查询
{
	struct Animal *tmp= phead;

	if(phead== NULL){
		printf("空\n");
		return NULL;
	}else{
		while(tmp != NULL){
			if(strcmp(tmp->name,str) == 0){
				return tmp;
			}
			tmp=tmp->next;
		}
		return NULL;
	}
}

int main()
{
	char buf[128]={'\0'};
	struct Animal *phead = NULL;
	struct Animal *ptmp;

	phead = putCatInLink(phead);
	phead = putDogInLink(phead);
	phead = putPersonInLink(phead);//至此已经组合完成整个链表

	
	while(1){
		printf("please input：Tom，ahuang, xiaoming\n");  //链表的查询
		scanf("%s",buf);
		ptmp = findUtilByName(buf,phead);

		if(ptmp != NULL){
		ptmp->pbeat();
		ptmp->peat();
		}
		memset(buf, '\0',sizeof(buf)); //此处不能用strlen
	}

	return 0;
}

```

#### cat.c

```c
#include "animal.h"

void catEat()
{
	printf("cat eat fish\n");
}

void catBeat()
{
	printf("cat bite your little brother\n");
}

struct Animal cat = {
	.name = "Tom",
	.peat = catEat,
	.pbeat = catBeat

};


struct Animal* putCatInLink(struct Animal *phead)
{
	if(phead == NULL){
		phead = &cat;
		return phead;
	}else{
		cat.next = phead;  //头插法
		phead = &cat;
		return phead;     //返回最新的头
		
	}
}

```

#### dog.c

```c
#include "animal.h"

void dogEat()
{
	printf("dog eat shi\n");
}

void dogBeat()
{
	printf("dog bite your little brother\n");
}

struct Animal dog = {
	.name = "ahuang",
	.peat = dogEat,
	.pbeat = dogBeat

};


struct Animal* putDogInLink(struct Animal *phead)
{
	if(phead == NULL){
		phead = &dog;
		return phead;
	}else{
		dog.next = phead;
		phead = &dog;
		return phead;
		
	}
}

```

#### person.c

```c
#include "animal.h"

void personEat()
{
	printf("person eat rice\n");
}

void personBeat()
{
	printf("person bite  your brother\n");
}
  
struct Animal person = {
	.name = "xiaoming",
	.peat = personEat,
	.pbeat = personBeat

};


struct Animal* putPersonInLink(struct Animal *phead)
{
	if(phead == NULL){
		phead = &person;
		return phead;
	}else{
		person.next = phead;
		phead = &person;
		return phead;
		
	}
}

```

##### 编译运行

![31](D:\Desktop\raspberry\raspberry\31.png)



##### 如若想在链表上加入其它的animal，直接新建编写一个.C文件，然后加入到链表中。

##### 这样就完成类似不断给智能家居加入新功能，同时也有助于代码的维护。

## 智能家居工厂模式整体设计框架



![32](D:\Desktop\raspberry\raspberry\32.png)

![33](D:\Desktop\raspberry\raspberry\33.png)



##### 通俗理解的步骤就是链表通用模板定义（在头文件里定义）、链表的创建（头插尾插，在.C 文件里）、链表的初始化（init配置管脚初始电平等）、链表内容的读取（指令工厂TCP服务端读取客户端发来的指令、串口读取语音模块发来的指令）、链表的遍历查找（找到控制工厂里面需要被控制的链表节点）、链表内容的写入（写入来自指令工厂的控制指令）。

##### 接收的指令，可以放在临时创建的变量里面，或者创建一个本地文件fd保存，或者一开始创建链表通用模板里面定义一个存放接收指令的数组，这样更方便访问。

### [继电器](https://so.csdn.net/so/search?q=继电器&spm=1001.2101.3001.7020)控制灯代码

#### contrlEquipments.h 文件（设备类）

```c
#include <wiringPi.h>					//wiringPi库
#include <stdio.h>
#include <stdlib.h>

struct Equipment						//设备类
{
	char equipName[128];				//设备名
	int pinNum;							//引脚号
	int (*Init)(int pinNum);			//“初始化设备”函数指针
	int (*open)(int pinNum);			//“打开设备”函数指针
	int (*close)(int pinNum);			//“关闭设备”函数指针

	int (*readStatus)(int pinNum);		//“读取设备状态”函数指针  为火灾报警器准备
	int (*changeStatus)(int status);	//“改变设备状态”函数指针

	struct Equipment *next;
};

struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead);			//“浴室灯”加入设备链表函数声明
struct Equipment *addSecondfloorLightToEquipmentLink(struct Equipment *phead);		//“二楼灯”加入设备链表函数声明
struct Equipment *addLivingroomLightToEquipmentLink(struct Equipment *phead);		//“客厅灯”加入设备链表函数声明
struct Equipment *addRestaurantLightToEquipmentLink(struct Equipment *phead);		//“餐厅灯”加入设备链表函数声明

```

#### mainPro.c 文件（主函数）

```c
#include <stdio.h>
#include <string.h>
#include "contrlEquipments.h"

int main()
{
	if(wiringPiSetup() == -1){								//使用wiringPi库，需初始化硬件				  
	printf("wiringPiSetup failed!\n");
	return -1; 
	}

	struct Equipment *pequipHead = NULL;				              //定义初始链表头
	pequipHead = addBathroomLightToEquipmentLink(pequipHead );        //“浴室灯”加入设备链表
	pequipHead = addSecondfloorLightToEquipmentLink(pequipHead );	  //“二楼灯”加入设备链表
	pequipHead = addLivingroomLightToEquipmentLink(pequipHead );	  //“客厅灯”加入设备链表
	pequipHead = addRestaurantLightToEquipmentLink(pequipHead );	  //“餐厅灯”加入设备链表

	struct Equipment *tmp = pequipHead ;
	while(tmp != NULL){					//继电器功能测试，打开链表上所有灯
		tmp->Init(tmp->pinNum);         //先初始化
		tmp->open(tmp->pinNum);
		tmp = tmp->next;
	}

	return 0;
}

```

#### bathroomLight.c 文件（浴室灯）

```c
#include "contrlEquipments.h"			//自定义设备类的文件

int bathroomLightInit();		//初始化继电器函数声明
int bathroomLightOpen();		//“打开灯”函数声明
int bathroomLightClose();		//“关闭灯”函数声明
//struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead);
//浴室灯（对象）加入设备链表函数声明

struct Equipment bathroomLight = {			//定义浴室灯（对象）
	.equipName = "bathroomLight",			//名字
	.pinNum = 2,							//树莓派 2号(wPi)引脚
	.Init = bathroomLightInit,				//指定初始化函数
	.open = bathroomLightOpen,				//指定“打开灯”函数
	.close = bathroomLightClose			    //指定“关闭灯”函数
};


int bathroomLightInit(int pinNum)           //C语言必须要传参，JAVA不用，可直接访问变量的值
{
	pinMode(pinNum,OUTPUT);					//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);				//引脚置高电平，断开继电器
}

int bathroomLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);				//引脚置低电平，闭合继电器
}

int bathroomLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);				//引脚置高电平，断开继电器
}

struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead)		//浴室灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &bathroomLight;
	}else{
		bathroomLight.next = phead;  //以前的头变成.next
		phead = &bathroomLight;      //更新头
		return phead;
	}
}

```

#### secondfloorLight.c 文件（二楼灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int secondfloorLightInit();			//初始化继电器函数声明
int secondfloorLightOpen();			//“打开灯”函数声明
int secondfloorLightClose();		//“关闭灯”函数声明
//struct Equipment *addSecondfloorLightToLink(struct Equipment *phead);
//二楼灯（对象）加入设备链表函数声明

struct Equipment secondfloorLight = {			//定义二楼灯（对象）
	.equipName = "secondfloorLight",			//名字
	.pinNum = 4,								//树莓派 4号(wPi)引脚
	.Init = secondfloorLightInit,				//指定初始化函数
	.open = secondfloorLightOpen,				//指定“打开灯”函数
	.close = secondfloorLightClose,				//指定“关闭灯”函数
};


int secondfloorLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int secondfloorLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int secondfloorLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addSecondfloorLightToEquipmentLink(struct Equipment *phead)		//二楼灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &secondfloorLight;
	}else{
		secondfloorLight.next = phead;
		phead = &secondfloorLight;
		return phead;
	}
}

```

#### livingroomLight.c 文件（客厅灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int livingroomLightInit();			//初始化继电器函数声明
int livingroomLightOpen();			//“打开灯”函数声明
int livingroomLightClose();			//“关闭灯”函数声明
//struct Equipment *addLivingroomLightToLink(struct Equipment *phead);
//客厅灯（对象）加入设备链表函数声明

struct Equipment livingroomLight = {			//定义客厅灯（对象）
	.equipName = "livingroomLight",				//名字
	.pinNum = 1,								//树莓派 1号(wPi)引脚
	.Init = livingroomLightInit,				//指定初始化函数
	.open = livingroomLightOpen,				//指定“打开灯”函数
	.close = livingroomLightClose,				//指定“关闭灯”函数
};


int livingroomLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int livingroomLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int livingroomLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addLivingroomLightToEquipmentLink(struct Equipment *phead)		//客厅灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &livingroomLight;
	}else{
		livingroomLight.next = phead;
		phead = &livingroomLight;
		return phead;
	}
}

```

#### restaurantLight.c 文件（餐厅灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int restaurantLightInit();			//初始化继电器函数声明
int restaurantLightOpen();			//“打开灯”函数声明
int restaurantLightClose();			//“关闭灯”函数声明
struct Equipment *addRestaurantLightToLink(struct Equipment *phead);
//餐厅灯（对象）加入设备链表函数声明

struct Equipment restaurantLight = {			//定义餐厅灯（对象）
	.equipName = "restaurantLight",				//名字
	.pinNum = 3,								//树莓派 3号(wPi)引脚
	.Init = restaurantLightInit,				//指定初始化函数
	.open = restaurantLightOpen,				//指定“打开灯”函数
	.close = restaurantLightClose,				//指定“关闭灯”函数
};


int restaurantLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int restaurantLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int restaurantLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addRestaurantLightToEquipmentLink(struct Equipment *phead)		//餐厅灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &restaurantLight;
	}else{
		restaurantLight.next = phead;
		phead = &restaurantLight;
		return phead;
	}
}

```

##### 编译运行：

![34](D:\Desktop\raspberry\raspberry\34.png)

![35](D:\Desktop\raspberry\raspberry\35.jpg)

##### 继电器四个灯都亮了

##### 由于mainPro.c文件中指定继电器功能测试，打开链表上所有灯，可以发现继电器组全部亮红灯（如下图所示）。也可以将实际的家居灯接入到继电器中实现控制灯光的效果。



#### 通过名字开关灯

##### 其他代码和上面的代码一样，就mainPro.c修改了一下

##### mainPro.c代码如下：

```c
#include <stdio.h>
#include <string.h>
#include "contrlEquipments.h"

struct Equipment* findDeviceByName(char *name, struct Equipment *pdeviceHead)
{
        while(pdeviceHead != NULL)
        {
        if(strcmp(name, pdeviceHead->equipName) == 0)
        {
                printf("找到了\n");
                return pdeviceHead;
        }
        pdeviceHead = pdeviceHead->next;
        }
        printf("没找到\n");
        return NULL;
}


int main()
{
        struct Equipment *rcv = NULL;
        char name[100];
        if(wiringPiSetup() == -1){                                                              //使用wiringPi库，需初始化硬件
                printf("wiringPiSetup failed!\n");
                return -1;
        }

        struct Equipment *pequipHead = NULL;                                          //定义初始链表头
        pequipHead = addBathroomLightToEquipmentLink(pequipHead );        //“浴室灯”加入设备链表
        pequipHead = addSecondfloorLightToEquipmentLink(pequipHead );     //“二楼灯”加入设备链表
        pequipHead = addLivingroomLightToEquipmentLink(pequipHead );      //“客厅灯”加入设备链表
        pequipHead = addRestaurantLightToEquipmentLink(pequipHead );      //“餐厅灯”加入设备链表

        struct Equipment *tmp = pequipHead ;
        while(tmp != NULL){                                     //继电器功能测试，关闭链表上所有灯
                tmp->Init(tmp->pinNum);         //先初始化
                tmp->close(tmp->pinNum);
                tmp = tmp->next;

        }

        printf("please input device's name\n");
        scanf("%s",name);
        rcv = findDeviceByName(name,pequipHead);
        rcv->open(rcv->pinNum);

        return 0;
}
```

##### 编译运行：

![36](D:\Desktop\raspberry\raspberry\36.png)

![37](D:\Desktop\raspberry\raspberry\37.jpg)





# 工厂模式火焰报警部分代码

### contrlEquipments.h 文件（设备类）

```c
#include <wiringPi.h>						//使用wiringPi库，也可使用自己写的驱动
#include <stdio.h>
#include <stdlib.h>

struct Equipment							//设备类
{
	char equipName[128];					//设备名
	int pinNum;								//引脚号
	int (*Init)(int pinNum);				//“初始化设备”函数指针
	int (*open)(int pinNum);				//“打开设备”函数指针
	int (*close)(int pinNum);				//“关闭设备”函数指针

	int (*readStatus)(int pinNum);			//“读取设备状态”函数指针
	int (*changeStatus)(int status);		//“改变设备状态”函数指针

	struct Equipment *next;
};

struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead);			//“浴室灯”加入设备链表函数声明
struct Equipment *addSecondfloorLightToEquipmentLink(struct Equipment *phead);		//“二楼灯”加入设备链表函数声明
struct Equipment *addLivingroomLightToEquipmentLink(struct Equipment *phead);		//“客厅灯”加入设备链表函数声明
struct Equipment *addRestaurantLightToEquipmentLink(struct Equipment *phead);		//“餐厅灯”加入设备链表函数声明
struct Equipment *addFireDetectionToEquipmentLink(struct Equipment *phead);			//“火焰传感器”加入设备链表函数声明
struct Equipment *addBuzzerToEquipmentLink(struct Equipment *phead);				//“蜂鸣器”加入设备链表函数声明

```

### mainPro.c 文件（主函数）

```c
#include <stdio.h>
#include <string.h>
#include "contrlEquipments.h"

int main()
{
	if(wiringPiSetup() == -1){									//使用wiringPi库，需初始化硬件
		printf("wiringPiSetup failed!\n");
		return -1; 
	}

	struct Equipment *pequipHead = NULL;						//定义初始链表首端
//	pequipHead = addBathroomLightToEquipmentLink(pequipHead);
//	pequipHead = addSecondfloorLightToEquipmentLink(pequipHead);
//	pequipHead = addLivingroomLightToEquipmentLink(pequipHead);
//	pequipHead = addRestaurantLightToEquipmentLink(pequipHead);
	pequipHead = addFireDetectionToEquipmentLink(pequipHead);	//“火焰传感器”加入设备链表
	pequipHead = addBuzzerToEquipmentLink(pequipHead );			//“蜂鸣器”加入设备链表

	int fireStatus;												//存放“火焰传感器”状态
	char *fireName = "fireDetection";
	char *buzzerName = "buzzer";
	struct Equipment *firetmp = pequipHead;
	struct Equipment *buztmp = pequipHead;

	while(buztmp != NULL){										//寻找链表中蜂鸣器对应链节
		if(strcmp(buzzerName,buztmp->equipName) == 0){
			buztmp->Init(buztmp->pinNum);						//初始化“蜂鸣器”
			break;
		}
		buztmp = buztmp->next;
	}
	
	while(firetmp != NULL){
		if(strcmp(fireName,firetmp->equipName) == 0){
			firetmp->Init(firetmp->pinNum);						//初始化火焰传感器的引脚为输入模式
			while(1){
				fireStatus = firetmp->readStatus(firetmp->pinNum);	//读取“火焰传感器”状态
				if(fireStatus == 0){							//“火焰传感器”处于 0状态
					buztmp->open(buztmp->pinNum);				//开启蜂鸣器
				}else if(fireStatus == 1){						//“火焰传感器”处于 1状态
					buztmp->close(buztmp->pinNum);				//关闭蜂鸣器
				}
				delay(1000);                      //有火蜂鸣器响一秒
			}
		}
		firetmp = firetmp->next;
	}

	return 0;
}

```

### fireDetection.c（火焰传感器）

```c
#include "contrlEquipments.h"							//自定义设备类的文件

int fireDetectionInit(int pinNum);				//初始化“火焰传感器”函数声明
int readFireDetectionStatus(int pinNum);		//读取“火焰传感器”状态函数声明


struct Equipment fireDetection = {				//定义火焰传感器（对象）
	.equipName = "fireDetection",				//名字
	.pinNum = 21,								//树莓派 21号(wPi)引脚
	.Init = fireDetectionInit,					//指定初始化函数
	.readStatus = readFireDetectionStatus,		//指定读取“火焰传感器”状态函数
};

int fireDetectionInit(int pinNum)
{
	pinMode(pinNum,INPUT);						//配置引脚为输入模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，状态为1
}

int readFireDetectionStatus(int pinNum)
{
	return digitalRead(pinNum);					//读取引脚电平，并返回，高电平返回 1，低电平返回 0(有火)
}

struct Equipment *addFireDetectionToEquipmentLink(struct Equipment *phead)		//火焰传感器（对象）加入设备链表函数
{
	if(phead == NULL){
		return &fireDetection;
	}else{
		fireDetection.next = phead;
		phead = &fireDetection;
		return phead;
	}
}

```

### buzzer.c 文件（蜂鸣器）

```c
#include "contrlEquipments.h"							//自定义设备类的文件

int buzzerInit(int pinNum);						//“初始化蜂鸣器”函数声明
int buzzerOpen(int pinNum);						//“开启蜂鸣器”函数声明
int buzzerClose(int pinNum);					//“关闭蜂鸣器”函数声明
struct Equipment *addBuzzerToLink(struct Equipment *phead);
//蜂鸣器（对象）加入设备链表函数声明

struct Equipment buzzer = {						//定义蜂鸣器（对象）
	.equipName = "buzzer",						//名字
	.pinNum = 22,								//树莓派 22号(wpi)引脚
	.Init = buzzerInit,							//指定初始化函数
	.open = buzzerOpen,							//指定“开启蜂鸣器”函数
	.close = buzzerClose,						//指定“关闭蜂鸣器”函数
};

int buzzerInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，蜂鸣器关闭
}

int buzzerOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，蜂鸣器开启
}

int buzzerClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，蜂鸣器关闭
}

struct Equipment *addBuzzerToEquipmentLink(struct Equipment *phead)		//蜂鸣器（对象）加入设备链表函数
{
	if(phead == NULL){
		return &buzzer;
	}else{
		buzzer.next = phead;
		phead = &buzzer;
		return phead;
	}
}

```

## 语音模块的开发（LU-ASR01智能语音控制模块）

#### 用天问block开发，代码如下：

```c
#include "asr.h"
#include "setup.h"
#include "HardwareSerial.h"
#include "myLib/luxiaoban.h"
#include "myLib/asr_event.h"

uint32_t snid;
void app();

//{ID:250,keyword:"命令词",ASR:"最大音量",ASRTO:"音量调整到最大"}
//{ID:251,keyword:"命令词",ASR:"中等音量",ASRTO:"音量调整到中等"}
//{ID:252,keyword:"命令词",ASR:"最小音量",ASRTO:"音量调整到最小"}
void app(){
  while (1) {
    if(luxiaoban_digital_read(7)==0){
      //{ID:500,keyword:"命令词",ASR:"耍接官",ASRTO:"门已打开，欢迎主人"}
      play_audio(500);
    }
    luxiaoban_digital_write(7,1);
    delay(1);
  }
  vTaskDelete(NULL);
}

void ASR_CODE()
{
  //{ID:501,keyword:"唤醒词",ASR:"小明同学",ASRTO:"我在"}
  if(snid == 501){
    Serial.println("hello");
    Serial.flush();
  }
  //{ID:502,keyword:"命令词",ASR:"打开浴室灯",ASRTO:"浴室灯已打开"}
  if(snid == 502){
    Serial.println("ysdo");
    Serial.flush();
  }
  //{ID:503,keyword:"命令词",ASR:"关闭浴室灯",ASRTO:"浴室灯已关闭"}
  if(snid == 503){
    Serial.println("ysdc");
    Serial.flush();
  }
  //{ID:504,keyword:"命令词",ASR:"打开二楼灯",ASRTO:"二楼灯已打开"}
  if(snid == 504){
    Serial.println("eldo");
    Serial.flush();
  }
  //{ID:505,keyword:"命令词",ASR:"关闭二楼灯",ASRTO:"二楼灯已关闭"}
  if(snid == 505){
    Serial.println("eldc");
    Serial.flush();
  }
  //{ID:506,keyword:"命令词",ASR:"打开客厅灯",ASRTO:"客厅灯已打开"}
  if(snid == 506){
    Serial.println("ktdo");
    Serial.flush();
  }
  //{ID:507,keyword:"命令词",ASR:"关闭客厅灯",ASRTO:"客厅灯已关闭"}
  if(snid == 507){
    Serial.println("ktdc");
    Serial.flush();
  }
  //{ID:508,keyword:"命令词",ASR:"打开餐厅灯",ASRTO:"餐厅灯已打开"}
  if(snid == 508){
    Serial.println("ctdo");
    Serial.flush();
  }
  //{ID:509,keyword:"命令词",ASR:"关闭餐厅灯",ASRTO:"餐厅灯已关闭"}
  if(snid == 509){
    Serial.println("ctdc");
    Serial.flush();
  }
  //{ID:510,keyword:"命令词",ASR:"开门",ASRTO:""}
  if(snid == 510){
    Serial.println("dooro");
    Serial.flush();
  }
  //{ID:511,keyword:"命令词",ASR:"打开所有灯光",ASRTO:"灯光已全部打开"}
  if(snid == 511){
    Serial.println("allo");
    Serial.flush();
  }
  //{ID:512,keyword:"命令词",ASR:"关闭所有灯光",ASRTO:"灯光已全部关闭"}
  if(snid == 512){
    Serial.println("allc");
    Serial.flush();
  }
}

void setup()
{
  Serial.begin(115200);
  luxiaoban_digital_write_all(1);
  //{speak:小蝶-清新女声,vol:10,speed:10,platform:haohaodada}
  //{playid:10001,voice:欢迎使用小明同学，用小明同学唤醒我。}
  //{playid:10002,voice:我退下了，用小明同学唤醒我}
  set_wakeup_forever();
  xTaskCreate(app,"app",128,NULL,1,NULL);
}

```



### 测试结果：

![38](D:\Desktop\raspberry\raspberry\38.png)



## 添加语音识别线程(树莓派一定要打开串口通信功能)

#### 其他.c文件和上面一样

#### 改动的是inputCommand.h和voiceControl.c

#### inputCommand.h代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wiringPi.h>
#include <wiringSerial.h>


struct Command
{
	char commandName[128];						//“控制方式”名
	char deviceFilesName[128];					//存放初始化所需文件的路径 串口用到
	char command[32];							//存放指令
	int fd;										//存放文件描述符
	int (*Init)(struct Command *file);			//“初始化”函数指针 C语言要传参 不太好的面向对象
	int s_fd;
	char ipAdress[32];
	char port[12];
	int (*getCommand)(struct Command *cmd);		//“获取指令”函数指针

	struct Command *next;
};

struct Command *addvoiceControlToCommandLink(struct Command *phead);		//“语音控制”加入指令链表函数声明

```

#### voiceControl.c代码如下：

```c
#include "inputCommand.h"			//自定义类文件
#include <unistd.h>

int voiceControlInit(struct Command *file);						//“语音控制”功能初始化函数声明

int voiceControlGetCommand(struct Command *cmd);					//“获取指令”函数初始化
struct Command *addVoiceControlToCommandLink(struct Command *phead);		//“语音控制”（对象）加入指令链表函数声明

struct Command voiceControl = {						//定义“语音控制”对象
	.commandName = "voiceControl",					//名字
	.deviceFilesName = "/dev/ttyAMA0",				//树莓派串口文件所在地址
	.command = {'\0'},								//初始化储存“指令”的空间
	.Init = voiceControlInit,						//指定“语音控制”功能初始化函数
	.getCommand = voiceControlGetCommand,			//指定“获取指令”函数
};

int voiceControlInit(struct Command *file)  //  C语言要传参，java可直接访问
{
	int fd;
	if((fd = serialOpen(file->deviceFilesName,115200)) == -1){		//打开树莓派串口，波特率指定为9600
		exit(-1);
	}
	file->fd = fd;	//(传过来的是地址)打开串口文件成功，返回“文件描述符”到“语音控制”链节中
}

int voiceControlGetCommand(struct Command *cmd)
{
	int nread = 0;
	nread = read(cmd->fd,cmd->command,sizeof(cmd->command));	//读取串口
	if(nread == 0){
		printf("usart for voice over time\n");
    }else{
	return nread;            //返回读取到数据的字节数,实际读取的指令放到了command里
	}												
}

struct Command *addVoiceControlToCommandLink(struct Command *phead)	//“语音控制”（对象）加入指令方式链表函数
{
	if(phead == NULL){
		return &voiceControl;
	}else{
		voiceControl.next = phead;
		phead = &voiceControl;
		return phead;
	}
}

```

#### mainPro.c代码如下：

```c
#include <stdio.h>
#include <string.h>
#include "inputCommand.h"
#include <pthread.h>
#include <unistd.h>

struct Command *addVoiceControlToCommandLink(struct Command *phead);
struct Command *findCommandByName(char *name,struct Command *phead);		//链节查找函数声明
void *voiceControl_thread(void *data);										//“语音控制”线程函数声明

struct Command *cmdhead = NULL;					//创建“指令”链表全局变量

int main()
{
	cmdhead = addVoiceControlToCommandLink(cmdhead);			//“语音控制”对象加入链表

	pthread_t voiceControl_thread_t;					//存放线程 ID

	pthread_create(&voiceControl_thread_t,NULL,voiceControl_thread,NULL);		//创建“语音控制”线程
	pthread_join(voiceControl_thread_t, NULL);			//主函数等待“语音控制”线程退出
	return 0;
}

//“语音控制”线程
void *voiceControl_thread(void *data)	//没用到data  create创建线程没进行传参			
{
	int nread;
	struct Command *voiceHandler = NULL;

	voiceHandler = findCommandByName("voiceControl",cmdhead);		//寻找“语音控制”链节，返回给voiceHandler
	if(voiceHandler == NULL){										//找不到
		printf("find voiceHandler error\n");
		pthread_exit(NULL);											//线程退出
	}else{															//找到
		if(voiceHandler->Init(voiceHandler) < 0){					//初始化
			printf("voiceHandler init error\n");					//初始化失败
			pthread_exit(NULL);										//线程退出
		}

		while(1){
			nread = voiceHandler->getCommand(voiceHandler);						//读取指令
			if(nread == 0){														//没接收到指令
				printf("No command received\n");
			}else{																//接收到指令
				printf("Get command:%s\n",voiceHandler->command);
			}
		}
	}
}

struct Command *findCommandByName(char *name,struct Command *phead)			//“控制方式”链表查找链节函数
{
	struct Command *tmp = phead;

	if(phead == NULL){
		return NULL;
	}

	while(tmp != NULL){
		if(strcmp(name,tmp->commandName) == 0){
			return tmp;
		}
		tmp = tmp->next;
	}
	return NULL;
}

```

##### 编译运行：

![40](D:\Desktop\raspberry\raspberry\40.png)





## 添加网络线程控制（socket）

### 网络线程控制代码如下

### inputCommand.h代码如下：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wiringPi.h>
#include <wiringSerial.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>


struct Command
{
	char commandName[128];						//“控制方式”名
	char deviceFilesName[128];					//存放初始化所需文件的路径
	char command[32];							//存放指令
	int fd;										//存放文件描述符（串口/网络）
	int (*Init)(struct Command *file);			//“初始化”函数指针
	int s_fd;									//存放服务器套接字描述符
	char ipAdress[32];							//存放 IP地址
	char port[12];								//存放端口号
	int (*getCommand)(struct Command *cmd);		//“获取指令”函数指针

	struct Command *next;
};

struct Command *addSocketControlToCommandLink(struct Command *phead);		//“网络控制”加入指令链表函数声明

```

### mainPro.c代码如下：

```c
#include <stdio.h>
#include <string.h>
#include "inputCommand.h"
#include <pthread.h>
#include <unistd.h>

struct Command *findCommandByName(char *name,struct Command *phead);		//寻找链节函数声明
void *socketControlThread(void *data);			//“网络控制”线程函数声明
void *socketReadThread(void *data);				//“读取端口”线程函数声明

struct Command *cmdhead = NULL;					//创建“指令”链表全局变量
struct Command *socketHandler = NULL;			//创建“链节处理”全局变量

int main()
{
	cmdhead = addSocketControlToCommandLink(cmdhead);		//“网络控制”对象加入链表

	pthread_t socketControl_thread;
	pthread_create(&socketControl_thread,NULL,socketControlThread,NULL);	//创建“网络控制”线程

	pthread_join(socketControl_thread, NULL);		//主函数等待“网络控制”线程退出
	return 0;
}

void *socketControlThread(void *data)				//“网络控制”线程
{
	int c_fd;											//文件描述符
	struct sockaddr_in c_addr;
	memset(&c_addr,0,sizeof(struct sockaddr_in));
	socklen_t clen = sizeof(struct sockaddr_in);
	pthread_t socketRead_thread;						//存放线程 ID


	socketHandler = findCommandByName("socketControl",cmdhead);			//寻找并返回“网络控制”所处链节
	if(socketHandler == NULL){											//若找不到
		printf("find socketHandler error\n");
		pthread_exit(NULL);
	}
	if(socketHandler->Init(socketHandler) < 0){							//执行“网络控制”功能初始化函数
		printf("socketControl init error\n");
		pthread_exit(NULL);
	}


	while(1){//不断等待连接 只要有连接进来，就创建线程去对接
		c_fd = accept(socketHandler->s_fd,(struct sockaddr*)&c_addr,&clen);		//接收连接请求
		socketHandler->fd = c_fd;												//发送文件描述符

		pthread_create(&socketRead_thread,NULL,socketReadThread,NULL);			//创建“读取端口”线程 连接一个客户端就去对接 可接纳10个客户端
	}
}
//创建新线程：用于读取TCP端口指令
//只要有连接，就创建线程去对接。线程共用内存资源，同一时刻，所有设备只有一种状态。也可PV操作
//所有线程 只操控一个结构体 再新来一个线程(新手机客户端接入) 前一个客户端失效 因为c_fd被改了。fork()可实现多个客户端同时控制
//不过好像寄存器和内存不是完全同步的 可能缓存没改？还可以多个客户端同时控制？
//如果直接把socketReadThread()拿过来循环的话，则同时刻不能接受新的客户端接入了，因为循环卡在了socketReadThread()函数里面了


//“读取端口”线程
void *socketReadThread(void *data)	//实际没传参			
{
	int nread;
	memset(socketHandler->command,'\0',sizeof(socketHandler->command));		//每次读取前，清空 “command（存放指令）”
	nread = read(socketHandler->fd,socketHandler->command,sizeof(socketHandler->command));		//读取客户端并存放到 “command”
	if(nread == 0){
		printf("No command received\n");
	}else{
		printf("Get command:%s\n",socketHandler->command);			//读取成功，打印数据
	}
}

struct Command *findCommandByName(char *name,struct Command *phead)			//通过“名字”寻找链节函数
{
	struct Command *tmp = phead;

	if(phead == NULL){
		return NULL;
	}

	while(tmp != NULL){
		if(strcmp(name,tmp->commandName) == 0){
			return tmp;
		}
		tmp = tmp->next;
	}
	return NULL;
}

```

### socketControl.c代码如下：

```c
#include "inputCommand.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>


int socketControlInit(struct Command *file);						//“网络控制”功能初始化函数声明
struct Command *addSocketControlToLink(struct Command *phead);		//“网络控制”（对象）加入指令链表函数声明


struct Command socketControl = {				//定义“网络控制”对象
	.commandName = "socketControl",				//名字
	.command = {'\0'},							//初始化储存“指令”的空间
	.Init = socketControlInit,					//指定“网络控制”功能初始化函数
	.ipAdress = "192.168.153.227",				    //树莓派 IP地址
	.port = "8088",								//打开的端口号
};

int socketControlInit(struct Command *file)
{
	int s_fd;											//套接字描述符
	struct sockaddr_in s_addr;
	memset(&s_addr,0,sizeof(struct sockaddr_in));

	s_fd = socket(AF_INET,SOCK_STREAM,0);				//创建套接字
    if(s_fd == -1){										//若创建套接字失败
            perror("socketControl error");
            exit(-1);
    }

	s_addr.sin_family = AF_INET;
    s_addr.sin_port = htons(atoi(file->port));
    inet_aton(file->ipAdress,&s_addr.sin_addr);
	if(bind(s_fd,(struct sockaddr*)&s_addr,sizeof(struct sockaddr_in)) == -1){		//套接字与端口号绑定
    	perror("bind error");
    	exit(-1);
    }

	if(listen(s_fd,10) == -1){							//打开监听
    	perror("listen error");
    	exit(-1);
    }

	file->s_fd = s_fd;									//发送套接字描述符
}

struct Command *addSocketControlToCommandLink(struct Command *phead)		//“网络控制”（对象）加入指令链表函数
{
	if(phead == NULL){
		return &socketControl;
	}else{
		socketControl.next = phead;
		phead = &socketControl;
		return phead;
	}
}

```

### 编译运行（下载网络调试助手）：

![41](D:\Desktop\raspberry\raspberry\41.png)

#### 手机下载网络调试助手，和树莓派连入同一个WIFI，输入树莓派IP地址以及端口号，发送消息：hello，树莓派接收消息成功。



![42](D:\Desktop\raspberry\raspberry\42.jpg)



# 智能家居项目整合（网络控制线程、语音控制线程，火灾报警线程）

## mainPro.c（主函数）

```c
#include <stdio.h>
#include <string.h>
#include "contrlEquipments.h"
#include "inputCommand.h"
#include <pthread.h>
#include <unistd.h>

struct Equipment *findEquipByName(char *name,struct Equipment *phead);		//一些函数声明
struct Command *findCommandByName(char *name,struct Command *phead);
void *voiceControlThread(void *data);
void *socketControlThread(void *data);
void *socketReadThread(void *data);
void *fireAlarmThread(void *data);
void *airAlarmThread(void *data);

struct Equipment *equiphead = NULL;			//设备工厂链表头节点
struct Command *cmdhead = NULL;				//指令控制工厂链表节点头
struct Command *socketHandler = NULL;		//“网络控制线程”执行的函数使用到的全局变量


int main()
{
	if(wiringPiSetup() == -1){					//使用wiringPi库需要初始化
		printf("wiringPiSetup failed!\n");
		return -1; 
	}

	pthread_t voiceControl_thread;
	pthread_t socketControl_thread;
	pthread_t fireAlarm_thread;
	pthread_t airAlarm_thread;

	//1、设备工厂初始化
	equiphead = addBathroomLightToEquipmentLink(equiphead);			//各设备加入设备工厂
	equiphead = addSecondfloorLightToEquipmentLink(equiphead);	
	equiphead = addLivingroomLightToEquipmentLink(equiphead);
	equiphead = addRestaurantLightToEquipmentLink(equiphead);
	equiphead = addFireDetectionToEquipmentLink(equiphead);
	equiphead = addBuzzerToEquipmentLink(equiphead);
	equiphead = addlockToEquipmentLink(equiphead);
	equiphead = addAirDetectionToEquipmentLink(equiphead);		//煤气传感器（对象）加入设备链表函数

	struct Equipment *tmpequiphead = equiphead;
	while(tmpequiphead != NULL){						//设备工厂所有设备初始化
		tmpequiphead->Init(tmpequiphead->pinNum);
		tmpequiphead = tmpequiphead->next;
	}


	//2、指令工厂初始化
	cmdhead = addVoiceControlToCommandLink(cmdhead);				//各指令控制加入指令控制工厂
	cmdhead = addSocketControlToCommandLink(cmdhead);



	//3、线程池建立
	//3.1 语音线程   
	//int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void *), void *restrict arg);  
	pthread_create(&voiceControl_thread,NULL,voiceControlThread,NULL);		//创建线程：语音控制
	//3.2 网络线程 		
	pthread_create(&socketControl_thread,NULL,socketControlThread,NULL);	//创建线程：网络控制
	//3.3 火灾线程 	
	pthread_create(&fireAlarm_thread,NULL,fireAlarmThread,NULL);			//创建线程：火灾报警系统
	//3.4 摄像头线程 
	//3.5煤气线程
	pthread_create(&airAlarm_thread,NULL,airAlarmThread,NULL);			//创建线程：火灾报警系统
	
	pthread_join(voiceControl_thread, NULL);		//主函数等待线程退出
	pthread_join(socketControl_thread, NULL);		//主函数等待线程退出
	pthread_join(fireAlarm_thread, NULL);			//主函数等待线程退出
	pthread_join(airAlarm_thread, NULL);			//主函数等待线程退出
	return 0;
}



void *voiceControlThread(void *data)			//“语音控制线程”执行的函数
{
	int nread;
	char *temName = NULL;
	struct Command *voiceHandler = NULL;
	struct Equipment *linkHandler;


	voiceHandler = findCommandByName("voiceControl",cmdhead);		//寻找“语音控制”所在节点，返回给voiceHandler
	if(voiceHandler == NULL){
		printf("find voiceHandler error\n");
		pthread_exit(NULL);
	}
	if(voiceHandler->Init(voiceHandler) < 0){				//“语音控制”功能初始化
		printf("voiceControl init error\n");
		pthread_exit(NULL);
	}


	while(1){
		nread = voiceHandler->getCommand(voiceHandler);			//获取指令
		if(nread == 0){											//没有获取到指令
			printf("No voiceCommand received\n");
		}else{													//获取到指令
			printf("Get voice command:%s\n",voiceHandler->command);

			//以下为根据不用指令执行相应操作

			//语音模块串口传出来的后面带\r\n，不加对比不出来
			if(strcmp("ycdo\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//改为泳池灯	
				linkHandler->open(linkHandler->pinNum);
				//printf("已打开浴室灯\n");
				printf("已打开泳池灯\n");
			}

			if(strcmp("ycdc\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
				//printf("已关闭浴室灯\n");
				printf("已关闭泳池灯\n");
			}

			if(strcmp("eldo\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("eldc\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("ktdo\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("ktdc\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("wsdo\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("restaurantLight",equiphead);//改为卧室灯
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("wsdc\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("allo\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//灯全部打开
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("allc\r\n",voiceHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//灯全部关闭
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}
			if(strcmp("dooro\r\n",voiceHandler->command) == 0)
			{
				system("./smartHomeFaceRec");
			}
			memset(voiceHandler->command,'\0',sizeof(voiceHandler->command));//不添加这个，不然只能识别一次

		}
	}
}


void *socketControlThread(void *data)				//“网络控制线程”执行的函数
{
	int c_fd;
	struct sockaddr_in c_addr;
	memset(&c_addr,0,sizeof(struct sockaddr_in));
	socklen_t clen = sizeof(struct sockaddr_in);
	pthread_t socketRead_thread; //线程里面套线程，网络连接后信息通信


	socketHandler = findCommandByName("socketControl",cmdhead);		//寻找“网络控制”所在节点，返回给socketHandler
	if(socketHandler == NULL){
		printf("find socketHandler error\n");
		pthread_exit(NULL);
	}
	if(socketHandler->Init(socketHandler) < 0){				//“网络控制”功能初始化
		printf("socketControl init error\n");
		pthread_exit(NULL);
	}


	while(1){
		c_fd = accept(socketHandler->s_fd,(struct sockaddr*)&c_addr,&clen);		//接收连接请求，阻塞至有客户端完成三次握手
		socketHandler->fd = c_fd;					//将套接字描述符返回给“网络控制”链表节点

		pthread_create(&socketRead_thread,NULL,socketReadThread,NULL);			//创建新线程：用于读取TCP端口指令
//只要有连接，就创建线程去对接。线程共用内存资源，同一时刻，所有设备只有一种状态。也可PV操作
//所有线程 只操控一个结构体 再新来一个线程(新手机客户端接入) 前一个客户端失效 因为c_fd被改了。fork()可实现多个客户端同时控制
//不过好像寄存器和内存不是完全同步的 可能缓存没改？还可以多个客户端同时控制？
//如果直接把socketReadThread()拿过来循环的话，则同时刻不能接受新的客户端接入了，因为循环卡在了socketReadThread()函数里面了
	}
}


void *socketReadThread(void *data)				//“读取tcp端口指令线程”执行的函数
{

	int nread;
	struct Equipment *linkHandler;
	//这里没加while循环，客户端只能发送一次
	while(1)
	{
	printf("socketConnect...");
		memset(socketHandler->command,'\0',sizeof(socketHandler->command));		//将指令存放的空间置空
	
		nread = read(socketHandler->fd,socketHandler->command,sizeof(socketHandler->command));		//读取指令
	
		if(nread == 0){
			printf("No socketCommand received\n");			//没有读取到指令
		}else{
			printf("Get socketCommand:%s\n",socketHandler->command);		//读取到指令

			//以下为根据不用指令执行相应操作

			if(strcmp("ycdo",socketHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//改为泳池灯	
				linkHandler->open(linkHandler->pinNum);
				//printf("已打开浴室灯\n");
				printf("已打开泳池灯\n");
			}

			if(strcmp("ycdc",socketHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
				//printf("已关闭浴室灯\n");
				printf("已关闭泳池灯\n");
			}

			if(strcmp("eldo",socketHandler->command) == 0){
				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("eldc",socketHandler->command) == 0){
				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("ktdo",socketHandler->command) == 0){
				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("ktdc",socketHandler->command) == 0){
				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("wsdo",socketHandler->command) == 0){
				linkHandler = findEquipByName("restaurantLight",equiphead);//改为卧室灯
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("wsdc",socketHandler->command) == 0){
				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}

			if(strcmp("allo",socketHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//灯全部打开
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->open(linkHandler->pinNum);

				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->open(linkHandler->pinNum);
			}

			if(strcmp("allc",socketHandler->command) == 0){
				linkHandler = findEquipByName("bathroomLight",equiphead);//灯全部关闭
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("secondfloorLight",equiphead);
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("livingroomLight",equiphead);
				linkHandler->close(linkHandler->pinNum);

				linkHandler = findEquipByName("restaurantLight",equiphead);
				linkHandler->close(linkHandler->pinNum);
			}
			if(strcmp("dooro",socketHandler->command) == 0)
			{
				linkHandler = findEquipByName("lock",equiphead);
				linkHandler->open(linkHandler->pinNum);
				delay(2000);
				linkHandler->close(linkHandler->pinNum);
			
			}

		}
	}
}


void *fireAlarmThread(void *data)//有火-返回高电平				//“火灾报警器线程”执行的函数
{
	int status;
	struct Equipment *firetmp = NULL;
	struct Equipment *buztmp = NULL;

	firetmp = findEquipByName("fireDetection",equiphead);		//寻找“火焰传感器”链表节点，返回给firetmp
	buztmp = findEquipByName("buzzer",equiphead);				//寻找“蜂鸣器”链表节点，返回给buztmp

	while(1){
		status = firetmp->readStatus(firetmp->pinNum);			//读取“火焰传感器”状态

		if(status == 1){						//检测到火焰或强光源
			buztmp->open(buztmp->pinNum);		//打开蜂鸣器
			perror("fire-why");
			delay(1000);						//延时1000毫秒=1秒
		}

		if(status == 0){						//未检测到火焰、强光源或解除警报
			buztmp->close(buztmp->pinNum);		//关闭蜂鸣器
		}
	}
}

void *airAlarmThread(void *data)//煤气泄漏-返回低电平				//“煤气泄漏报警器线程”执行的函数
{
	int status;
	struct Equipment *airtmp = NULL;
	struct Equipment *buztmp = NULL;

	airtmp = findEquipByName("airDetection",equiphead);		//寻找“煤气传感器”链表节点，返回给airtmp
	buztmp = findEquipByName("buzzer",equiphead);				//寻找“蜂鸣器”链表节点，返回给buztmp

	while(1){
		status = airtmp->readStatus(airtmp->pinNum);			//读取“煤气传感器”状态
/*	//玄学，加了煤气检测代码，要煤气检测，和火灾同时有，蜂鸣器才能响
		if(status == 0){						//检测到煤气
			buztmp->open(buztmp->pinNum);		//打开蜂鸣器
			perror("air-why");
			delay(1500);						//延时1000毫秒=1秒
		}

		if(status == 1){						//未检测到煤气解除警报
			buztmp->close(buztmp->pinNum);		//关闭蜂鸣器
		}
*/
		}
}

struct Equipment *findEquipByName(char *name,struct Equipment *phead)		//根据名字寻找设备工厂链表链节函数，并返回链节
{
	struct Equipment *tmp = phead;

	if(phead == NULL){
		return NULL;
	}

	while(tmp != NULL){
		if(strcmp(name,tmp->equipName) == 0){
			return tmp;
		}
		tmp = tmp->next;
	}
	return NULL;
}


struct Command *findCommandByName(char *name,struct Command *phead)			//根据名字寻找指令控制工厂链表链节函数，并返回链节
{
	struct Command *tmp = phead;

	if(phead == NULL){
		return NULL;
	}

	while(tmp != NULL){
		if(strcmp(name,tmp->commandName) == 0){
			return tmp;
		}
		tmp = tmp->next;
	}
	return NULL;
}


```

## 指令工厂

## inputCommand.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wiringPi.h>
#include <wiringSerial.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

struct Command								//指令控制工厂链表节点定义
{
	char commandName[128];					//“控制方式”名字
	char deviceFilesName[128];				//存放初始化功能需要打开的文件的路径
	char command[32];						//存放指令
	int fd;									//存放文件描述符 用于串口/客户端fd
	int (*Init)(struct Command *file);		//“初始化”函数指针
	int s_fd;								//存放套接字描述符
	char ipAdress[32];						//存放IP地址
	char port[12];							//存放端口号
	int (*getCommand)(struct Command *cmd);	//“获取指令”函数指针
	char log[1024];							//日志（暂未使用）

	struct Command *next;
};

struct Command *addVoiceControlToCommandLink(struct Command *phead);		//“语音控制”加入指令控制工厂链表函数声明
struct Command *addSocketControlToCommandLink(struct Command *phead);		//“网络控制”加入指令控制工厂链表函数声明

```

## voiceControl.c（语音控制）

```c
#include "inputCommand.h"
#include <unistd.h>

int voiceControlInit(struct Command *file);							//“语音控制”功能初始化函数声明
int voiceControlGetCommand(struct Command *cmd);					//“获取指令”函数声明
//struct Command *addVoiceControlToLink(struct Command *phead);		//“语音控制”加入指令控制工厂链表函数声明


struct Command voiceControl = {				//“语音控制”链表节点
	.commandName = "voiceControl",
	.deviceFilesName = "/dev/ttyAMA0",
	.command = {'\0'},
	.Init = voiceControlInit,             //这里只是定义，还未调用改函数
	.getCommand = voiceControlGetCommand,
	.log = {'\0'},
};


int voiceControlInit(struct Command *file)
{
	int fd;
	if((fd = serialOpen(file->deviceFilesName,9600)) == -1){		//打开树莓派串口，波特率为9600
		exit(-1);
	}
	file->fd = fd;				//打开串口文件成功，返回“文件描述符”到“语音控制”链表节点中
}


int voiceControlGetCommand(struct Command *cmd)					//“获取指令”函数
{
	int nread = 0;
	memset(cmd->command,'\0',sizeof(cmd->command));					//防止老的消息影响新的消息
	nread = read(cmd->fd,cmd->command,sizeof(cmd->command));		//返回读取到数据的字节数
	return nread;
}


struct Command *addVoiceControlToCommandLink(struct Command *phead)		//头插法将“语音控制”链表节点加入指令控制工厂链表函数
{
	if(phead == NULL){
		return &voiceControl;
	}else{
		voiceControl.next = phead;
		phead = &voiceControl;
		return phead;
	}
}

```

## socketControl.c（网络线程）

```c
#include "inputCommand.h"
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <string.h>
#include <unistd.h>


int socketControlInit(struct Command *file);					//“网络控制”功能初始化函数声明
//struct Command *addSocketControlToLink(struct Command *phead);	//“网络控制”加入指令控制工厂链表函数声明


struct Command socketControl = {		//“网络控制”链表节点
	.commandName = "socketControl",
	.command = {'\0'},
	.Init = socketControlInit,
	.ipAdress = "192.168.0.19",		//树莓派连接网络时的IP地址
	.port = "8088",						//树莓派打开待外界连接的端口号
	.log = {'\0'},
};


int socketControlInit(struct Command *file)
{
	int s_fd;											//套接字描述符
	struct sockaddr_in s_addr;
	memset(&s_addr,0,sizeof(struct sockaddr_in));

	s_fd = socket(AF_INET,SOCK_STREAM,0);				//创建套接字
    if(s_fd == -1){										//创建套接字失败时
            perror("socketControl error");
            exit(-1);
    }

	s_addr.sin_family = AF_INET;
    s_addr.sin_port = htons(atoi(file->port));
    inet_aton(file->ipAdress,&s_addr.sin_addr);
	if(bind(s_fd,(struct sockaddr*)&s_addr,sizeof(struct sockaddr_in)) == -1){		//套接字与端口号绑定
    	perror("bind error");
    	exit(-1);
    }

	if(listen(s_fd,10) == -1){		//打开监听 accept放到主函数线程里
    	perror("listen error");
    	exit(-1);
    }

	file->s_fd = s_fd;						//套接字描述符返回到“网络控制”链表节点
}


struct Command *addSocketControlToCommandLink(struct Command *phead)			//头插法将设备节点加入设备工厂链表函数
{
	if(phead == NULL){
		return &socketControl;
	}else{
		socketControl.next = phead;
		phead = &socketControl;
		return phead;
	}
}

```

# 控制工厂

## contrlEquipments.h

```c
#include <wiringPi.h>					//wiringPi库
#include <stdio.h>
#include <stdlib.h>
struct Equipment						//设备类
{
	char equipName[128];				//设备名
	int pinNum;							//引脚号
	int (*Init)(int pinNum);			//“初始化设备”函数指针
	int (*open)(int pinNum);			//“打开设备”函数指针
	int (*close)(int pinNum);			//“关闭设备”函数指针

	int (*readStatus)(int pinNum);		//“读取设备状态”函数指针  为火灾报警器准备
	int (*changeStatus)(int status);	//“改变设备状态”函数指针

	struct Equipment *next;
};

struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead);		//“浴室灯”加入设备链表函数声明
struct Equipment *addSecondfloorLightToEquipmentLink(struct Equipment *phead);		//“二楼灯”加入设备链表函数声明
struct Equipment *addLivingroomLightToEquipmentLink(struct Equipment *phead);		//“客厅灯”加入设备链表函数声明
struct Equipment *addRestaurantLightToEquipmentLink(struct Equipment *phead);		//“餐厅灯”加入设备链表函数声明
struct Equipment *addFireDetectionToEquipmentLink(struct Equipment *phead);			//“火焰传感器”加入设备链表函数声明
struct Equipment *addBuzzerToEquipmentLink(struct Equipment *phead);				//“蜂鸣器”加入设备链表函数声明
struct Equipment *addlockToEquipmentLink(struct Equipment *phead);		//“电磁锁加入设备链表函数声明”

```



## bathroomLight.c（浴室灯）

```c
#include "contrlEquipments.h"			//自定义设备类的文件

int bathroomLightInit();		//初始化继电器函数声明
int bathroomLightOpen();		//“打开灯”函数声明
int bathroomLightClose();		//“关闭灯”函数声明
//struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead);
////浴室灯（对象）加入设备链表函数声明

struct Equipment bathroomLight = {			//定义浴室灯（对象）
	.equipName = "bathroomLight",			//名字
	.pinNum = 2,							//树莓派 2号(wPi)引脚
	.Init = bathroomLightInit,				//指定初始化函数
	.open = bathroomLightOpen,				//指定“打开灯”函数
	.close = bathroomLightClose			    //指定“关闭灯”函数
};


int bathroomLightInit(int pinNum)           //C语言必须要传参，JAVA不用，可直接访问变量的值
{
	pinMode(pinNum,OUTPUT);					//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);				//引脚置高电平，断开继电器
}

int bathroomLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);				//引脚置低电平，闭合继电器
}
int bathroomLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);				//引脚置高电平，断开继电器
}

struct Equipment *addBathroomLightToEquipmentLink(struct Equipment *phead)		//浴室灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &bathroomLight;
	}else{
		bathroomLight.next = phead;  //以前的头变成.next
		phead = &bathroomLight;      //更新头
		return phead;
	}
}


```

## secondfloorLight.c（二楼灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int secondfloorLightInit();			//初始化继电器函数声明
int secondfloorLightOpen();			//“打开灯”函数声明
int secondfloorLightClose();		//“关闭灯”函数声明

//struct Equipment *addSecondfloorLightToLink(struct Equipment *phead);
////二楼灯（对象）加入设备链表函数声明

struct Equipment secondfloorLight = {			//定义二楼灯（对象）
	.equipName = "secondfloorLight",			//名字
	.pinNum = 4,								//树莓派 4号(wPi)引脚
	.Init = secondfloorLightInit,				//指定初始化函数
	.open = secondfloorLightOpen,				//指定“打开灯”函数
	.close = secondfloorLightClose,				//指定“关闭灯”函数
};


int secondfloorLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int secondfloorLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int secondfloorLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addSecondfloorLightToEquipmentLink(struct Equipment *phead)		//二楼灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &secondfloorLight;
	}else{
		secondfloorLight.next = phead;
		phead = &secondfloorLight;
		return phead;
	}
}



```

## livingroomLight.c（客厅灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int livingroomLightInit();			//初始化继电器函数声明
int livingroomLightOpen();			//“打开灯”函数声明
int livingroomLightClose();			//“关闭灯”函数声明
//struct Equipment *addLivingroomLightToLink(struct Equipment *phead);
//客厅灯（对象）加入设备链表函数声明
/*
struct Equipment						//设备类
{
	char equipName[128];				//设备名
	int pinNum;							//引脚号
	int (*Init)(int pinNum);			//“初始化设备”函数指针
	int (*open)(int pinNum);			//“打开设备”函数指针
	int (*close)(int pinNum);			//“关闭设备”函数指针

	int (*readStatus)(int pinNum);		//“读取设备状态”函数指针  为火灾报警器准备
	int (*changeStatus)(int status);	//“改变设备状态”函数指针

	struct Equipment *next;
};
*/

struct Equipment livingroomLight = {			//定义客厅灯（对象）
	.equipName = "livingroomLight",				//名字
	.pinNum = 1,						//树莓派 1号(wPi)引脚
	.Init = livingroomLightInit,				//指定初始化函数
	.open = livingroomLightOpen,				//指定“打开灯”函数
	.close = livingroomLightClose,				//指定“关闭灯”函数
};


int livingroomLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int livingroomLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int livingroomLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addLivingroomLightToEquipmentLink(struct Equipment *phead)		//客厅灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &livingroomLight;
	}else{
		livingroomLight.next = phead;
		phead = &livingroomLight;
		return phead;
	}
}

```

## restaurantLight.c（餐厅灯）

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int restaurantLightInit();			//初始化继电器函数声明
int restaurantLightOpen();			//“打开灯”函数声明
int restaurantLightClose();			//“关闭灯”函数声明
struct Equipment *addRestaurantLightToLink(struct Equipment *phead);
//餐厅灯（对象）加入设备链表函数声明


struct Equipment restaurantLight = {			//定义餐厅灯（对象）
	.equipName = "restaurantLight",				//名字
	.pinNum = 3,								//树莓派 3号(wPi)引脚
	.Init = restaurantLightInit,				//指定初始化函数
	.open = restaurantLightOpen,				//指定“打开灯”函数
	.close = restaurantLightClose,				//指定“关闭灯”函数
};


int restaurantLightInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int restaurantLightOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int restaurantLightClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addRestaurantLightToEquipmentLink(struct Equipment *phead)		//餐厅灯（对象）加入设备链表函数
{
	if(phead == NULL){
		return &restaurantLight;
	}else{
		restaurantLight.next = phead;
		phead = &restaurantLight;
		return phead;
	}
}


```

## fireDetection.c（火焰传感器）

```c
#include "contrlEquipments.h"

int fireDetectionInit(int pinNum);					//一些函数声明
int readFireDetectionStatus(int pinNum);
//struct Equipment *addFireDetectionToLink(struct Equipment *phead);


struct Equipment fireDetection = {			//“火焰传感器”设备链表节点
	.equipName = "fireDetection",
	.pinNum = 21,							//树莓派gpio引脚21
	.Init = fireDetectionInit,
	.readStatus = readFireDetectionStatus,
};


int fireDetectionInit(int pinNum)			//初始化函数
{
	pinMode(pinNum,INPUT);					//配置引脚为输入引脚
	digitalWrite(pinNum,HIGH);				//引脚输出高电平，即默认为关闭状态
}

int readFireDetectionStatus(int pinNum)		//读取“火焰传感器”状态函数
{
	return digitalRead(pinNum);
}


struct Equipment *addFireDetectionToEquipmentLink(struct Equipment *phead)
{
	if(phead == NULL){
		return &fireDetection;
	}else{
		fireDetection.next = phead;
		phead = &fireDetection;
		return phead;
	}
}

```

## buzzer.c 文件（蜂鸣器）

```c
#include "contrlEquipments.h"

int buzzerInit(int pinNum);					//一些函数声明
int buzzerOpen(int pinNum);
int buzzerClose(int pinNum);
struct Equipment *addBuzzerToEquipmentLink(struct Equipment *phead);


struct Equipment buzzer = {			//“蜂鸣器”设备链表节点
	.equipName = "buzzer",
	.pinNum = 22,					//树莓派gpio引脚22
	.Init = buzzerInit,
	.open = buzzerOpen,
	.close = buzzerClose,
};


int buzzerInit(int pinNum)					//初始化函数
{
	pinMode(pinNum,OUTPUT);					//配置引脚为输出引脚
	digitalWrite(pinNum,HIGH);				//引脚输出高电平，即默认为关闭状态
}

int buzzerOpen(int pinNum)					//打开函数
{
	digitalWrite(pinNum,LOW);
}

int buzzerClose(int pinNum)					//关闭函数
{
	digitalWrite(pinNum,HIGH);
}


struct Equipment *addBuzzerToEquipmentLink(struct Equipment *phead)			//头插法将设备节点加入设备工厂链表函数
{
	if(phead == NULL){
		return &buzzer;
	}else{
		buzzer.next = phead;
		phead = &buzzer;
		return phead;
	}
}

```

## lock.c

```c
#include "contrlEquipments.h"				//自定义设备类的文件

int lockInit();			//初始化继电器函数声明
int lockOpen();			//“打开lock”函数声明
int lockClose();			//“关闭lock”函数声明

struct Equipment lock = {			//定义客厅lock（对象）
	.equipName = "lock",				//名字
	.pinNum = 5,						//树莓派 5号(wPi)引脚
	.Init = lockInit,				//指定初始化函数
	.open = lockOpen,				//指定“打开lock”函数
	.close = lockClose,				//指定“关闭lock”函数
};


int lockInit(int pinNum)
{
	pinMode(pinNum,OUTPUT);						//配置引脚为输出模式
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

int lockOpen(int pinNum)
{
	digitalWrite(pinNum,LOW);					//引脚置低电平，闭合继电器
}

int lockClose(int pinNum)
{
	digitalWrite(pinNum,HIGH);					//引脚置高电平，断开继电器
}

struct Equipment *addlockToEquipmentLink(struct Equipment *phead)		//lock（对象）加入设备链表函数
{
	if(phead == NULL){
		return &lock;
	}else{
		lock.next = phead;
		phead = &lock;
		return phead;
	}
}

```

## camera.c(人脸识别)

```c
#include <stdio.h>
#include <curl/curl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>
#include <fcntl.h>
#include<wiringPi.h>

#define true 1
#define false 0
typedef unsigned int bool;


int gpio_init(void)
{
	int err_num = wiringPiSetup();
	pinMode(5, OUTPUT);
	digitalWrite(5,HIGH);
	pinMode(29, OUTPUT);
	digitalWrite(29,HIGH);
	return err_num;
}

void lock_open(void)
{
	digitalWrite(5,LOW);
	digitalWrite(29,LOW);
	delay(20);
	digitalWrite(29,HIGH);
	delay(2000);
	digitalWrite(5,HIGH);
}

size_t read_func( void *ptr, size_t size, size_t nmemb, void *stream)
{
        char buf[1024] = {0};
        strncpy(buf, ptr, 1024);
        printf("======================get data======================\n");
        printf("%s\n",buf);

        printf("=====================result=======================\n");
        if(strstr(buf,"是") != NULL)
        {
		lock_open();
                printf("the same person\n");
        }
        else
        {
                printf("different person\n");
        }

}
char* getPicBase64FromFile(char *filePath)
{

        char *bufPic;
        char cmd[128]={'\0'};

        sprintf(cmd,"base64 %s >tmpFile",filePath);

        system(cmd);

        int fd = open("./tmpFile",O_RDWR);
        int fd_len = lseek(fd,0,SEEK_END);
        lseek(fd,0,SEEK_SET);

        bufPic = (char*)malloc(fd_len+2);

        memset(bufPic,'\0',fd_len+2);

        read(fd,bufPic,fd_len);

        close(fd);

        system("rm -rf tmpFile");

        return bufPic;

}

bool postUrl()
{
        CURL *curl;
        CURLcode res;

        char *postString;

        char *img1;
        char *img2;
        char *key = "7qUgFcjemNwL5m5dCFH7gk";
        char *secret = "c8a238f46dae4ea3a98eb8baaa2ab2d0";
        int typeId = 21;
        char *formate = "xml";

	//拍摄图片
	system("raspistill -o after.jpg -t 1000");

        //图片转字符流

        img1 = getPicBase64FromFile("./before.jpg");

        img2 = getPicBase64FromFile("./after.jpg");
	
	//删除拍摄的图片
	system("rm -rf after.jpg");

        postString = (char*)malloc(strlen(key)+strlen(secret)+strlen(img1)+strlen(img2)+1024);
        memset(postString,'\0',strlen(postString));

        //字符串拼接
        sprintf(postString,"&img1=%s&img2=%s&key=%s&secret=%s&typeId=%d&formate=%s",
                        img1,     img2,    key,    secret,   typeId,    formate);

        curl = curl_easy_init();
        if (curl)
        {
                curl_easy_setopt(curl, CURLOPT_COOKIEFILE, "/tmp/cookie.txt"); // 指定cookie文件
                curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postString);    // 指定post内容
                curl_easy_setopt(curl, CURLOPT_URL,"https://netocr.com/api/faceliu.do");   // 指定url
                curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, read_func); //通过回调函数存储数据
                res = curl_easy_perform(curl);

                printf("OK:%d\n",res);


                curl_easy_cleanup(curl);
        }
        free(img1);
        free(img2);
        free(postString);
        return true;
}
int main(void)
{
	int err_num = gpio_init();
	if(err_num == -1)
	{
		return -1;
	}

        postUrl();
}



```

## 语音模块部分：

```c
#include "asr.h"
#include "setup.h"
#include "HardwareSerial.h"
#include "myLib/luxiaoban.h"
#include "myLib/asr_event.h"

uint32_t snid;
void app();

//{ID:250,keyword:"命令词",ASR:"最大音量",ASRTO:"音量调整到最大"}
//{ID:251,keyword:"命令词",ASR:"中等音量",ASRTO:"音量调整到中等"}
//{ID:252,keyword:"命令词",ASR:"最小音量",ASRTO:"音量调整到最小"}
void app(){
  while (1) {
    if(luxiaoban_digital_read(7)==0){
      //{ID:500,keyword:"命令词",ASR:"耍接官",ASRTO:"门已打开，欢迎主人"}
      play_audio(500);
    }
    luxiaoban_digital_write(7,1);
    delay(1);
  }
  vTaskDelete(NULL);
}

void ASR_CODE()
{
  //{ID:501,keyword:"唤醒词",ASR:"小明同学",ASRTO:"我在"}
  if(snid == 501){
    Serial.println("hello");
    Serial.flush();
  }
  //{ID:502,keyword:"命令词",ASR:"打开泳池灯",ASRTO:"泳池灯已打开"}
  if(snid == 502){
    Serial.println("ycdo");
    Serial.flush();
  }
  //{ID:503,keyword:"命令词",ASR:"关闭泳池灯",ASRTO:"泳池灯已关闭"}
  if(snid == 503){
    Serial.println("ycdc");
    Serial.flush();
  }
  //{ID:504,keyword:"命令词",ASR:"打开二楼灯",ASRTO:"二楼灯已打开"}
  if(snid == 504){
    Serial.println("eldo");
    Serial.flush();
  }
  //{ID:505,keyword:"命令词",ASR:"关闭二楼灯",ASRTO:"二楼灯已关闭"}
  if(snid == 505){
    Serial.println("eldc");
    Serial.flush();
  }
  //{ID:506,keyword:"命令词",ASR:"打开客厅灯",ASRTO:"客厅灯已打开"}
  if(snid == 506){
    Serial.println("ktdo");
    Serial.flush();
  }
  //{ID:507,keyword:"命令词",ASR:"关闭客厅灯",ASRTO:"客厅灯已关闭"}
  if(snid == 507){
    Serial.println("ktdc");
    Serial.flush();
  }
  //{ID:508,keyword:"命令词",ASR:"打开卧室灯",ASRTO:"卧室灯已打开"}
  if(snid == 508){
    Serial.println("wsdo");
    Serial.flush();
  }
  //{ID:509,keyword:"命令词",ASR:"关闭卧室灯",ASRTO:"卧室灯已关闭"}
  if(snid == 509){
    Serial.println("wsdc");
    Serial.flush();
  }
  //{ID:510,keyword:"命令词",ASR:"开门",ASRTO:""}
  if(snid == 510){
    Serial.println("dooro");
    Serial.flush();
  }
  //{ID:511,keyword:"命令词",ASR:"打开所有灯光",ASRTO:"灯光已全部打开"}
  if(snid == 511){
    Serial.println("allo");
    Serial.flush();
  }
  //{ID:512,keyword:"命令词",ASR:"关闭所有灯光",ASRTO:"灯光已全部关闭"}
  if(snid == 512){
    Serial.println("allc");
    Serial.flush();
  }
}

void setup()
{
  Serial.begin(115200);
  luxiaoban_digital_write_all(1);
  //{speak:小蝶-清新女声,vol:10,speed:10,platform:haohaodada}
  //{playid:10001,voice:欢迎使用小明同学，用小明同学唤醒我。}
  //{playid:10002,voice:我退下了，用小明同学唤醒我}
  set_wakeup_forever();
  xTaskCreate(app,"app",128,NULL,1,NULL);
}

```



## 所有代码：

![43](D:\Desktop\raspberry\raspberry\43.png)



![44](D:\Desktop\raspberry\raspberry\44.png)





